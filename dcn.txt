--------------------------------------------------------------------VRC

#include<stdio.h>
#include<conio.h>
int binary(int);
void parity(int[]);
int arr[9],arr1[9];
char chr;
int temp,temp1,i,j;
void main()  {
       char chr1;
clrscr();
printf("Enter Data :");
scanf("%c %c",&chr,&chr1);
            temp=chr;
            binary(temp);
printf("\nAscii value is : %d\n",temp);
printf("\nBinary Form : ");
 for(i=0;i<8;i++)  {
printf("%d ",arr1[i]);
  }
printf("\n");
            parity(arr1);
            temp1=chr1;
            binary(temp1);
printf("\n\nAscii value is : %d\n",temp1);
printf("\nBinary Form : ");
    for(i=0;i<8;i++)   {
printf("%d ",arr1[i]);
                        }
printf("\n");  parity(arr1);
	getch();
}
void parity(int a[])  {
int count;
            count=0;
            for(i=0;i<8;i++) {
                if(a[i]==1)
                count++;
                             }
     if(count%2==0)
a[8]=0;
            else
		  a[8]=1;
            count=0;
printf("Receiver Side :\n");
printf("\n\nVRC : \n");
            for(i=0;i<9;i++)  {
   			if(i==8)
printf(" | ");
printf("%d ",a[i]);
                        }
}
intbinary(int x) {
intrem,t;
	inti=0;
	    while(x!=0)     {
			rem=x%2;
			arr[i]=rem;
			x=x/2;
			i++;
	    }
t=8-i;
for(j=0;j<t;j++)   {
arr1[j]=0;
}
for(j=t;j<=7;j++)  {
i--;
arr1[j]=arr[i];
}
	return(0);
}






--------------------------------------------------------CRC


import java.util.*;
import java.util.*;
class CRC {
  public static void main(String args[]) {
    Scanner scan = new Scanner(System.in);
    int n;
    //Accept the input
    System.out.println("Enter the size of the data:");
    n = scan.nextInt();
    int data[] = new int[n];
    System.out.println("Enter the data, bit by bit:");
    for(int i=0 ; i < n ; i++) {
      System.out.println("Enter bit number " + (n-i) + ":");
      data[i] = scan.nextInt();
    }
    
    // Accept the divisor
    System.out.println("Enter the size of the divisor:");
    n = scan.nextInt();
    int divisor[] = new int[n];
    System.out.println("Enter the divisor, bit by bit:");
    for(int i=0 ; i < n ; i++) {
      System.out.println("Enter bit number " + (n-i) + ":");
      divisor[i] = scan.nextInt();
    }
// Divide the inputted data by the inputted divisor   
// Store the remainder that is returned by the method
    int remainder[] = divide(data, divisor);
    for(int i=0 ; i < remainder.length-1 ; i++) {
      System.out.print(remainder[i]);
    }
    System.out.println("\nThe CRC code generated is:");
    
    for(int i=0 ; i < data.length ; i++) {
      System.out.print(data[i]);
    }
    for(int i=0 ; i < remainder.length-1 ; i++) {
      System.out.print(remainder[i]);
    }
System.out.println();
    
// Create a new array
// It will have the remainder generated by the above method appended
// to the inputted data
  int sent_data[] = new int[data.length + remainder.length - 1];
  System.out.println("Enter the data to be sent:");
  for(int i=0 ; i < sent_data.length ; i++) {
System.out.println("Enter bit number " + (sent_data.length-i)+ ":");
    sent_data[i] = scan.nextInt();
    }
    receive(sent_data, divisor);
  }
  static int[] divide(int old_data[], int divisor[]) {
    int remainder[] , i;

    int data[] = new int[old_data.length + divisor.length];
    System.arraycopy(old_data, 0, data, 0, old_data.length);
    // Remainder array stores the remainder
    remainder = new int[divisor.length];
    // Initially, remainder's bits will be set to the data bits
    System.arraycopy(data, 0, remainder, 0, divisor.length);
// Loop runs for same number of times as number of bits of data
// This loop will continuously exor the bits of the remainder and
    // divisor
    for(i=0 ; i < old_data.length ; i++) {
      System.out.println((i+1) + ".) First data bit is : "
                + remainder[0]);
      System.out.print("Remainder : ");
      if(remainder[0] == 1) {
    // We have to exor the remainder bits with divisor bits
        for(int j=1 ; j < divisor.length ; j++) {
        remainder[j-1] = exor(remainder[j], divisor[j]);
          System.out.print(remainder[j-1]);
        }
      }
      else {
        // We have to exor the remainder bits with 0
        for(int j=1 ; j < divisor.length ; j++) {
          remainder[j-1] = exor(remainder[j], 0);
          System.out.print(remainder[j-1]);
        }
      }
// The last bit of the remainder will be taken from the data
// This is the 'carry' taken from the dividend after every step              // of division
      remainder[divisor.length-1] = data[i+divisor.length];
      System.out.println(remainder[divisor.length-1]);
    }
    return remainder;
  }
    static int exor(int a, int b) {
    // This simple function returns the exor of two bits
    if(a == b) {
      return 0;
    }
    return 1;
  }
  static void receive(int data[], int divisor[]) {
// This is the receiver method
// It accepts the data and divisor (although the receiver already has
// the divisor value stored, with no need for the sender to resend it) 
    int remainder[] = divide(data, divisor);
    // Division is done
    for(int i=0 ; i < remainder.length ; i++) {
      if(remainder[i] != 0) {
// If remainder is not zero then there is an error
  System.out.println("There is an error in received data...");
        return;
      }
    }
    //Otherwise there is no error in the received  data
    System.out.println("Data was received without any error.");
  }
}







-----------------------------------------------------------hamming code

#include<iostream> 
using namespace std;
 
int main() {
    int data[10];
    int dataatrec[10],c,c1,c2,c3,i;
 
    cout<<"Enter 4 bits of data one by one\n";
    cin>>data[0];
    cin>>data[1];
    cin>>data[2];
    cin>>data[4];
 
    //Calculation of even parity
    data[6]=data[0]^data[2]^data[4];
    data[5]=data[0]^data[1]^data[4];
    data[3]=data[0]^data[1]^data[2];
 
    cout<<"\nEncoded data is\n";
    for(i=0;i<7;i++)
        cout<<data[i];
    
    cout<<"\n\nEnter received data bits one by one\n";
    for(i=0;i<7;i++)
        cin>>dataatrec[i];
 
    c1=dataatrec[6]^dataatrec[4]^dataatrec[2]^dataatrec[0];
    c2=dataatrec[5]^dataatrec[4]^dataatrec[1]^dataatrec[0];
    c3=dataatrec[3]^dataatrec[2]^dataatrec[1]^dataatrec[0];
    c=c3*4+c2*2+c1 ;
 
    if(c==0) {
        cout<<"\nNo error while transmission of data\n";
    }
    else {
        cout<<"\nError on position "<<c;
        
        cout<<"\nData sent : ";
        for(i=0;i<7;i++)
            cout<<data[i];
        
        cout<<"\nData received : ";
        for(i=0;i<7;i++)
            cout<<dataatrec[i];
        
        cout<<"\nCorrect message is\n";
        
        //if errorneous bit is 0 we complement it else vice versa
        if(dataatrec[7-c]==0)
            dataatrec[7-c]=1;
        else
             dataatrec[7-c]=0;
        for (i=0;i<7;i++) {
            cout<<dataatrec[i];
        }
    }
        return 0;
}














------------------------------------------------Djikshtra


import java.util.*;
public class Dijkstra
{
 public  int distance[] = new int[10];
 public  int cost[][] = new int[10][10];
  public void calc(int n,int s)
 {
  int flag[] = new int[n+1];
  int i,min,pos=1,k,c,minimum;
    for(i=1;i<=n;i++)
  {  
            flag[i]=0; 
      this.distance[i]=this.cost[s][i]; 
     }
     c=2;
  while(c<=n)
  {
   minimum=99;
   for(k=1;k<=n;k++)
   { 
          if(this.distance[k]<minimum && flag[k]!=1)
       {
        minimum=this.distance[i];
        minpos=k;
       }
      } 
         
   flag[minpos]=1;
      c++;
      for(k=1;k<=n;k++)
 {
         if(this.distance[minpos]+this.cost[minpos][k] <  this.distance[k] && flag[k]!=1 )
    this.distance[k]=this.distance[minpos]+this.cost[minpos][k];
 }   
  }   
 }
 public static void main(String args[])
 {
  int nodes,source,i,j;
  Scanner in = new Scanner(System.in);
  System.out.println("Enter the Number of Nodes \n");
  nodes = in.nextInt();
  Dijkstra d = new Dijkstra();
  System.out.println("Enter the Cost Matrix Weights: \n");
        for(i=1;i<=nodes;i++)
          for(j=1;j<=nodes;j++)    {
            d.cost[i][j]=in.nextInt();
            if(d.cost[i][j]==0)
              d.cost[i][j]=999;
          }
  System.out.println("Enter the Source Vertex :\n");
  source=in.nextInt();
  d.calc(nodes,source);
  System.out.println("The Shortest Path from Source \t"+source+"\t to all other vertices are : \n");
        for(i=1;i<=nodes;i++)
       
   if(i!=source)
 System.out.println("source :"+source+"\t destination :"+i+"\t MinCost is :"+d.distance[i]+"\t");
     } 
}



-----------------------------------------------------bellmen ford algo - distance vector algo

import java.util.Scanner;
public class BellmanFord  {
    private int distances[];
    private int numberofvertices;
    public static final int MAX_VALUE = 999;
    public BellmanFord(int numberofvertices)  {
        this.numberofvertices = numberofvertices;
        distances = new int[numberofvertices + 1];
    }
    public void BellmanFordEvaluation(int source, int adjacencymatrix[][])       {
        for (int node = 1; node <= numberofvertices; node++)        {
            distances[node] = MAX_VALUE;
        }
        distances[source] = 0;
 for (int node = 1; node <= numberofvertices - 1; node++)       {
for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)          {
 if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE) {
 if (distances[destinationnode] > distances[sourcenode] 
    + adjacencymatrix[sourcenode][destinationnode])
    distances[destinationnode] = distances[sourcenode]
      + adjacencymatrix[sourcenode][destinationnode];
                    }
                }
            }
        }
   for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)        {
   for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)            {
      if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
      if (distances[destinationnode] > distances[sourcenode]
          + adjacencymatrix[sourcenode][destinationnode])
       System.out.println("The Graph contains negative egde cycle");
                }
            }
 for (int vertex = 1; vertex <= numberofvertices; vertex++)        {
 System.out.println("distance of source"+source+"to"
                      +vertex+ "is" + distances[vertex]);
        }
    }
  public static void main(String... arg)    {
        int numberofvertices = 0;
        int source;
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter the number of vertices");
        numberofvertices = scanner.nextInt();
int adjacencymatrix[][] = new int[numberofvertices + 1][numberofvertices + 1];
        System.out.println("Enter the adjacency matrix");
for (int sourcenode = 1; sourcenode<=numberofvertices; sourcenode++) {
for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)            {
adjacencymatrix[sourcenode][destinationnode] = scanner.nextInt();
if (sourcenode == destinationnode)                {
   adjacencymatrix[sourcenode][destinationnode] = 0;
         continue;
                }
 if (adjacencymatrix[sourcenode][destinationnode] == 0)        {
      adjacencymatrix[sourcenode][destinationnode] = MAX_VALUE;
                }
            }
        }
        System.out.println("Enter the source vertex");
        source = scanner.nextInt();
       BellmanFord bellmanford = new BellmanFord(numberofvertices);
        bellmanford.BellmanFordEvaluation(source, adjacencymatrix);
        scanner.close();  
    }
}













---------------------------------------------------------------  tcp client server

//tcpserver.java
import java.io.*;
import java.net.*;
public class Tcpserver  {
public static void main(String a[]) throws Exception  {
System.out.println("TCP SERVER");
System.out.println("Server is ready to connect…");
ServerSocket serversoc=new ServerSocket(9);
Socket clientsoc = serversoc.accept();
PrintWriter out = new PrintWriter(clientsoc.getOutputStream(), true);
BufferedReader in = new BufferedReader(new 
InputStreamReader(clientsoc.getInputStream()));
String inputline;
BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
 try  {
while (true)  {
inputline = stdin.readLine();
out.println(inputline);
System.out.println("Client Says : "+in.readLine());
} 
}
catch(Exception e) {
System.exit(0);
}
  } 
}

//tcpclient.java
import java.io.*;
import java.net.*;
public class tcpclient  {
public static void main(String[] args) throws IOException  {
System.out.println("TCP CLIENT");
System.out.println("Enter the host name to connect");
DataInputStream inp=new DataInputStream(System.in);
String str=inp.readLine();
Socket clientsoc = new Socket(str, 9);
PrintWriter out = new PrintWriter(clientsoc.getOutputStream(), true);
BufferedReader in = new BufferedReader(new 
InputStreamReader(clientsoc.getInputStream()));
BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
String userinput;
 try  {
while (true)
{
System.out.println("Sever Says : " + in.readLine());
userinput = stdin.readLine();
out.println(userinput);
}
}
catch(Exception e)  {
System.exit(0);
}
}
}